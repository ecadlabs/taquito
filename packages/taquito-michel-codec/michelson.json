{
  "instructions": {
    "FAILWITH": {
      "op": "FAILWITH",
      "op_args": "FAILWITH",
      "ty": [
        {
          "name": "t_instr_FAILWITH",
          "premises": [],
          "conclusion": "ctx :- FAILWITH :: ty1 : A => B"
        }
      ],
      "semantics": [
        {
          "name": "bs_FAILWITH",
          "premises": [],
          "conclusion": "FAILWITH / d : stack => [FAILED]"
        }
      ]
    },
    "NEVER": {
      "op": "NEVER",
      "op_args": "NEVER",
      "ty": [
        {
          "name": "t_instr_NEVER",
          "premises": [],
          "conclusion": "ctx :- NEVER :: never : A => B"
        }
      ],
      "semantics": []
    },
    "NOOP": {
      "op": "NOOP",
      "op_args": "{}",
      "ty": [
        {
          "name": "t_instr_NOOP",
          "premises": [],
          "conclusion": "ctx :- {} :: A => A"
        }
      ],
      "semantics": [
        { "name": "bs_NOOP", "premises": [], "conclusion": "{} / S => S" }
      ]
    },
    "SEQ": {
      "op": "SEQ",
      "op_args": "instr1 ; instr2",
      "ty": [
        {
          "name": "t_instr_SEQ",
          "premises": [
            "ctx :- instr1 :: A => B", "ctx :- instr2 :: B => C"
          ],
          "conclusion": "ctx :- instr1 ; instr2 :: A => C"
        }
      ],
      "semantics": [
        {
          "name": "bs_SEQ",
          "premises": [ "i1 / S => SE'", "i2 / SE' => SE" ],
          "conclusion": "i1 ; i2 / S => SE"
        }
      ]
    },
    "IF": {
      "op": "IF",
      "op_args": "IF instr1 instr2",
      "ty": [
        {
          "name": "t_instr_IF",
          "premises": [
            "ctx :- instr1 :: A => B", "ctx :- instr2 :: A => B"
          ],
          "conclusion": "ctx :- IF instr1 instr2 :: bool : A => B"
        }
      ],
      "semantics": [
        {
          "name": "bs_IF__tt",
          "premises": [ "i1 / S => S'" ],
          "conclusion": "IF i1 i2 / True : S => S'"
        },
        {
          "name": "bs_IF__ff",
          "premises": [ "i2 / S => S'" ],
          "conclusion": "IF i1 i2 / False : S => S'"
        }
      ]
    },
    "LOOP": {
      "op": "LOOP",
      "op_args": "LOOP instr",
      "ty": [
        {
          "name": "t_instr_LOOP",
          "premises": [ "ctx :- instr :: A => bool : A" ],
          "conclusion": "ctx :- LOOP instr :: bool : A => A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LOOP__tt",
          "premises": [ "instr ; LOOP instr / S => S'" ],
          "conclusion": "LOOP instr / True : S => S'"
        },
        {
          "name": "bs_LOOP__ff",
          "premises": [],
          "conclusion": "LOOP instr / False : S => S"
        }
      ]
    },
    "LOOP_LEFT": {
      "op": "LOOP_LEFT",
      "op_args": "LOOP_LEFT instr",
      "ty": [
        {
          "name": "t_instr_LOOP_LEFT",
          "premises": [ "ctx :- instr :: ty1 : A => or ty1 ty2 : A" ],
          "conclusion": "ctx :- LOOP_LEFT instr :: or ty1 ty2 : A => ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LOOP_LEFT__tt",
          "premises": [ "i1 ; LOOP_LEFT i1 / d : S => S'" ],
          "conclusion": "LOOP_LEFT i1 / Left d : S => S'"
        },
        {
          "name": "bs_LOOP_LEFT__ff",
          "premises": [],
          "conclusion": "LOOP_LEFT i1 / Right d : S => d : S'"
        }
      ]
    },
    "DIP": {
      "op": "DIP",
      "op_args": "DIP instr",
      "ty": [
        {
          "name": "t_instr_DIP",
          "premises": [ "ctx :- instr :: B => C" ],
          "conclusion": "ctx :- DIP instr :: ty : B => ty : C"
        }
      ],
      "semantics": [
        {
          "name": "bs_DIP",
          "premises": [ "instr / S => S'" ],
          "conclusion": "DIP instr / d : S => d : S'"
        }
      ]
    },
    "DIPN": {
      "op": "DIPN",
      "op_args": "DIP n instr",
      "ty": [
        {
          "name": "t_instr_DIPN",
          "premises": [ "length A = n", "ctx :- instr :: B => C" ],
          "conclusion": "ctx :- DIP n instr :: A @ B => A @ C"
        }
      ],
      "semantics": [
        {
          "name": "bs_DIPN",
          "premises": [ "length S1 = n", "instr / S2 => S3" ],
          "conclusion": "DIP n instr / S1 ++ S2 => S1 ++ S3"
        }
      ]
    },
    "DIG": {
      "op": "DIG",
      "op_args": "DIG n",
      "ty": [
        {
          "name": "t_instr_DIG",
          "premises": [ "length A = n" ],
          "conclusion": "ctx :- DIG n :: A @ ( ty1 : B ) => ty1 : ( A @ B )"
        }
      ],
      "semantics": [
        {
          "name": "bs_DIG",
          "premises": [ "length S1 = n" ],
          "conclusion": "DIG n / S1 ++ ( d : S2 ) => d : ( S1 ++ S2 )"
        }
      ]
    },
    "DUG": {
      "op": "DUG",
      "op_args": "DUG n",
      "ty": [
        {
          "name": "t_instr_DUG",
          "premises": [ "length A = n" ],
          "conclusion": "ctx :- DUG n :: ty1 : ( A @ B ) => A @ ( ty1 : B )"
        }
      ],
      "semantics": [
        {
          "name": "bs_DUG",
          "premises": [ "length S1 = n" ],
          "conclusion": "DUG n / d : ( S1 ++ S2 ) => S1 ++ ( d : S2 )"
        }
      ]
    },
    "DROP": {
      "op": "DROP",
      "op_args": "DROP n",
      "ty": [
        {
          "name": "t_instr_DROP",
          "premises": [ "length A = n" ],
          "conclusion": "ctx :- DROP n :: A @ B => B"
        }
      ],
      "semantics": [
        {
          "name": "bs_DROP",
          "premises": [],
          "conclusion": "DROP n / d : S => S"
        }
      ]
    },
    "ITER": {
      "op": "ITER",
      "op_args": "ITER instr",
      "ty": [
        {
          "name": "t_instr_ITER__list",
          "premises": [ "ctx :- instr :: ty : A => A" ],
          "conclusion": "ctx :- ITER instr :: list ty : A => A"
        },
        {
          "name": "t_instr_ITER__set",
          "premises": [ "ctx :- instr :: cty : A => A" ],
          "conclusion": "ctx :- ITER instr :: set cty : A => A"
        },
        {
          "name": "t_instr_ITER__map",
          "premises": [ "ctx :- instr :: ( pair kty vty ) : A => A" ],
          "conclusion": "ctx :- ITER instr :: map kty vty : A => A"
        }
      ],
      "semantics": [
        {
          "name": "bs_ITER__set_nil",
          "premises": [],
          "conclusion": "ITER instr / {} : S => S"
        },
        {
          "name": "bs_ITER__set_cons",
          "premises": [ "instr ; ITER instr / x : tl : S => S'" ],
          "conclusion": "ITER instr / { x ; < tl > } : S => S'"
        },
        {
          "name": "bs_ITER__map_nil",
          "premises": [],
          "conclusion": "ITER instr / {} : S => S"
        },
        {
          "name": "bs_ITER__map_cons",
          "premises": [ "instr ; ITER instr / ( Pair k v ) : m : S => S'" ],
          "conclusion": "ITER instr / { Elt k v ; < m > } : S => S'"
        },
        {
          "name": "bs_ITER__list_cons",
          "premises": [ "instr ; ITER instr / d : tl : S => S'" ],
          "conclusion": "ITER instr / { d ; < tl > } : S => S'"
        },
        {
          "name": "bs_ITER__list_nil",
          "premises": [],
          "conclusion": "ITER instr / {} : S => S"
        }
      ]
    },
    "MAP": {
      "op": "MAP",
      "op_args": "MAP instr",
      "ty": [
        {
          "name": "t_instr_MAP__list",
          "premises": [ "ctx :- instr :: ty : A => ty2 : A" ],
          "conclusion": "ctx :- MAP instr :: list ty : A => list ty2 : A"
        },
        {
          "name": "t_instr_MAP__map",
          "premises": [ "ctx :- instr :: ( pair kty ty1 ) : A => ty2 : A" ],
          "conclusion":
            "ctx :- MAP instr :: map kty ty1 : A => map kty ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_MAP__list_nil",
          "premises": [],
          "conclusion": "MAP instr / {} : S => {} : S"
        },
        {
          "name": "bs_MAP__list_cons",
          "premises": [
            "instr / d : S => d' : S", "MAP instr / tl : S => tl' : S"
          ],
          "conclusion":
            "MAP instr / { d ; < tl > } : S => { d' ; < tl' > } : S"
        },
        {
          "name": "bs_MAP__map_nil",
          "premises": [],
          "conclusion": "MAP body / {} : S => {} : S"
        },
        {
          "name": "bs_MAP__map_cons",
          "premises": [
            "body / ( Pair k v ) : S => v' : S", "MAP body / m : S => m' : S"
          ],
          "conclusion":
            "MAP body / { Elt k v ; < m > } : S => { Elt k v' ; < m' > } : S"
        }
      ]
    },
    "IF_NONE": {
      "op": "IF_NONE",
      "op_args": "IF_NONE instr1 instr2",
      "ty": [
        {
          "name": "t_instr_IF_NONE",
          "premises": [
            "ctx :- instr1 :: A => B", "ctx :- instr2 :: ty1 : A => B"
          ],
          "conclusion": "ctx :- IF_NONE instr1 instr2 :: option ty1 : A => B"
        }
      ],
      "semantics": [
        {
          "name": "bs_IF_NONE__none",
          "premises": [ "instr1 / S => S'" ],
          "conclusion": "IF_NONE instr1 instr2 / None : S => S'"
        },
        {
          "name": "bs_IF_NONE__some",
          "premises": [ "instr2 / d : S => S'" ],
          "conclusion": "IF_NONE instr1 instr2 / ( Some d ) : S => S'"
        }
      ]
    },
    "IF_LEFT": {
      "op": "IF_LEFT",
      "op_args": "IF_LEFT instr1 instr2",
      "ty": [
        {
          "name": "t_instr_IF_LEFT",
          "premises": [
            "ctx :- instr1 :: ty1 : A => B", "ctx :- instr2 :: ty2 : A => B"
          ],
          "conclusion": "ctx :- IF_LEFT instr1 instr2 :: or ty1 ty2 : A => B"
        }
      ],
      "semantics": [
        {
          "name": "bs_IF_LEFT__left",
          "premises": [ "instr1 / d1 : S => S'" ],
          "conclusion": "IF_LEFT instr1 instr2 / ( Left d1 ) : S => S'"
        },
        {
          "name": "bs_IF_LEFT__right",
          "premises": [ "instr2 / d2 : S => S'" ],
          "conclusion": "IF_LEFT instr1 instr2 / ( Right d2 ) : S => S'"
        }
      ]
    },
    "IF_CONS": {
      "op": "IF_CONS",
      "op_args": "IF_CONS instr1 instr2",
      "ty": [
        {
          "name": "t_instr_IF_CONS",
          "premises": [
            "ctx :- instr1 :: ty : list ty : A => B",
            "ctx :- instr2 :: A => B"
          ],
          "conclusion": "ctx :- IF_CONS instr1 instr2 :: list ty : A => B"
        }
      ],
      "semantics": [
        {
          "name": "bs_IF_CONS__nil",
          "premises": [ "body2 / S => S'" ],
          "conclusion": "IF_CONS instr1 instr2 / {} : S => S'"
        },
        {
          "name": "bs_IF_CONS__cons",
          "premises": [ "instr1 / d : tl : S => S'" ],
          "conclusion": "IF_CONS instr1 instr2 / { d ; < tl > } : S => S'"
        }
      ]
    },
    "CREATE_CONTRACT": {
      "op": "CREATE_CONTRACT",
      "op_args":
        "CREATE_CONTRACT { parameter ty1 ; storage ty2 ; code instr1 }",
      "ty": [
        {
          "name": "t_instr_CREATE_CONTRACT",
          "premises": [
            "Some ty2 :- instr :: pair ty2 ty1 : [] => pair ( list operation ) ty1 : []"
          ],
          "conclusion":
            "ctx :- CREATE_CONTRACT { parameter ty1 ; storage ty2 ; code instr1 } :: option key_hash : mutez : ty2 : A => operation : address : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_CREATE_CONTRACT",
          "premises": [
            "create_contract ty1 ty2 instr1 kh z x = ( op , addr )"
          ],
          "conclusion":
            "CREATE_CONTRACT { parameter ty1 ; storage ty2 ; code instr1 } / kh : z : x : S => op : addr : S"
        }
      ]
    },
    "PUSH": {
      "op": "PUSH",
      "op_args": "PUSH ty x",
      "ty": [
        {
          "name": "t_instr_PUSH",
          "premises": [ "ctx :- x :: ty1" ],
          "conclusion": "ctx :- PUSH ty x :: A => ty1 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_PUSH",
          "premises": [],
          "conclusion": "PUSH ty d / S => d : S"
        }
      ]
    },
    "UNIT": {
      "op": "UNIT",
      "op_args": "UNIT",
      "ty": [
        {
          "name": "t_instr_UNIT",
          "premises": [],
          "conclusion": "ctx :- UNIT :: A => unit : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_UNIT",
          "premises": [],
          "conclusion": "UNIT / S => Unit : S"
        }
      ]
    },
    "LAMBDA": {
      "op": "LAMBDA",
      "op_args": "LAMBDA ty1 ty2 instr",
      "ty": [
        {
          "name": "t_instr_LAMBDA",
          "premises": [ "None :- instr :: ty1 : [] => ty2 : []" ],
          "conclusion":
            "ctx :- LAMBDA ty1 ty2 instr :: A => lambda ty1 ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LAMBDA",
          "premises": [],
          "conclusion":
            "LAMBDA ty1 ty2 instr / S => { instr : ty1 -> ty2 } : S"
        }
      ]
    },
    "APPLY": {
      "op": "APPLY",
      "op_args": "APPLY",
      "ty": [
        {
          "name": "t_instr_APPLY",
          "premises": [],
          "conclusion":
            "ctx :- APPLY :: ty1 : lambda ( pair ty1 ty2 ) ty3 : A => lambda ty2 ty3 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_APPLY",
          "premises": [],
          "conclusion":
            "APPLY / d : { i : ( pair ty1 ty2 ) -> ty3 } : S => { PUSH ty1 d ; PAIR ; i : ty2 -> ty3 } : S"
        }
      ]
    },
    "EMPTY_SET": {
      "op": "EMPTY_SET",
      "op_args": "EMPTY_SET cty",
      "ty": [
        {
          "name": "t_instr_EMPTY_SET",
          "premises": [],
          "conclusion": "ctx :- EMPTY_SET cty :: A => set cty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_EMPTY_SET",
          "premises": [],
          "conclusion": "EMPTY_SET cty / S => {} : S"
        }
      ]
    },
    "EMPTY_MAP": {
      "op": "EMPTY_MAP",
      "op_args": "EMPTY_MAP kty vty",
      "ty": [
        {
          "name": "t_instr_EMPTY_MAP",
          "premises": [],
          "conclusion": "ctx :- EMPTY_MAP kty vty :: A => map kty vty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_EMPTY_MAP",
          "premises": [],
          "conclusion": "EMPTY_MAP kty vty / S => {} : S"
        }
      ]
    },
    "EMPTY_BIG_MAP": {
      "op": "EMPTY_BIG_MAP",
      "op_args": "EMPTY_BIG_MAP kty vty",
      "ty": [
        {
          "name": "t_instr_EMPTY_BIG_MAP",
          "premises": [],
          "conclusion":
            "ctx :- EMPTY_BIG_MAP kty vty :: A => big_map kty vty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_EMPTY_BIG_MAP",
          "premises": [],
          "conclusion": "EMPTY_BIG_MAP kty vty / S => {} : S"
        }
      ]
    },
    "NONE": {
      "op": "NONE",
      "op_args": "NONE ty",
      "ty": [
        {
          "name": "t_instr_NONE",
          "premises": [],
          "conclusion": "ctx :- NONE ty :: A => option ty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_NONE",
          "premises": [],
          "conclusion": "NONE ty / S => None : S"
        }
      ]
    },
    "NIL": {
      "op": "NIL",
      "op_args": "NIL ty",
      "ty": [
        {
          "name": "t_instr_NIL",
          "premises": [],
          "conclusion": "ctx :- NIL ty :: A => list ty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_NIL",
          "premises": [],
          "conclusion": "NIL ty / S => {} : S"
        }
      ]
    },
    "BALANCE": {
      "op": "BALANCE",
      "op_args": "BALANCE",
      "ty": [
        {
          "name": "t_instr_BALANCE",
          "premises": [],
          "conclusion": "ctx :- BALANCE :: A => mutez : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_BALANCE",
          "premises": [],
          "conclusion": "BALANCE / S => balance : S"
        }
      ]
    },
    "SOURCE": {
      "op": "SOURCE",
      "op_args": "SOURCE",
      "ty": [
        {
          "name": "t_instr_SOURCE",
          "premises": [],
          "conclusion": "ctx :- SOURCE :: A => address : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SOURCE",
          "premises": [],
          "conclusion": "SOURCE / S => source : S"
        }
      ]
    },
    "SENDER": {
      "op": "SENDER",
      "op_args": "SENDER",
      "ty": [
        {
          "name": "t_instr_SENDER",
          "premises": [],
          "conclusion": "ctx :- SENDER :: A => address : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SENDER",
          "premises": [],
          "conclusion": "SENDER / S => sender : S"
        }
      ]
    },
    "SELF": {
      "op": "SELF",
      "op_args": "SELF",
      "ty": [
        {
          "name": "t_instr_SELF",
          "premises": [ "ctx = Some ty" ],
          "conclusion": "ctx :- SELF :: A => contract ty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SELF",
          "premises": [],
          "conclusion": "SELF / S => self : S"
        }
      ]
    },
    "SELF_ADDRESS": {
      "op": "SELF_ADDRESS",
      "op_args": "SELF_ADDRESS",
      "ty": [
        {
          "name": "t_instr_SELF_ADDRESS",
          "premises": [],
          "conclusion": "ctx :- SELF_ADDRESS :: A => address : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SELF_ADDRESS",
          "premises": [],
          "conclusion": "SELF_ADDRESS / S => address self : S"
        }
      ]
    },
    "AMOUNT": {
      "op": "AMOUNT",
      "op_args": "AMOUNT",
      "ty": [
        {
          "name": "t_instr_AMOUNT",
          "premises": [],
          "conclusion": "ctx :- AMOUNT :: A => mutez : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_AMOUNT",
          "premises": [],
          "conclusion": "AMOUNT / S => amount : S"
        }
      ]
    },
    "NOW": {
      "op": "NOW",
      "op_args": "NOW",
      "ty": [
        {
          "name": "t_instr_NOW",
          "premises": [],
          "conclusion": "ctx :- NOW :: A => timestamp : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_NOW",
          "premises": [],
          "conclusion": "NOW / S => now : S"
        }
      ]
    },
    "LEVEL": {
      "op": "LEVEL",
      "op_args": "LEVEL",
      "ty": [
        {
          "name": "t_instr_LEVEL",
          "premises": [],
          "conclusion": "ctx :- LEVEL :: A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LEVEL",
          "premises": [],
          "conclusion": "LEVEL / S => level : S"
        }
      ]
    },
    "VOTING_POWER": {
      "op": "VOTING_POWER",
      "op_args": "VOTING_POWER",
      "ty": [
        {
          "name": "t_instr_VOTING_POWER",
          "premises": [],
          "conclusion": "ctx :- VOTING_POWER :: key_hash : A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_VOTING_POWER",
          "premises": [],
          "conclusion": "VOTING_POWER / s : S => voting_power s : S"
        }
      ]
    },
    "TOTAL_VOTING_POWER": {
      "op": "TOTAL_VOTING_POWER",
      "op_args": "TOTAL_VOTING_POWER",
      "ty": [
        {
          "name": "t_instr_TOTAL_VOTING_POWER",
          "premises": [],
          "conclusion": "ctx :- TOTAL_VOTING_POWER :: A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_TOTAL_VOTING_POWER",
          "premises": [],
          "conclusion":
            "TOTAL_VOTING_POWER / s : S => total_voting_power : S"
        }
      ]
    },
    "HASH_KEY": {
      "op": "HASH_KEY",
      "op_args": "HASH_KEY",
      "ty": [
        {
          "name": "t_instr_HASH_KEY",
          "premises": [],
          "conclusion": "ctx :- HASH_KEY :: key : A => key_hash : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_HASH_KEY",
          "premises": [],
          "conclusion": "HASH_KEY / s : S => hash_key s : S"
        }
      ]
    },
    "NOT": {
      "op": "NOT",
      "op_args": "NOT",
      "ty": [
        {
          "name": "t_instr_NOT__bool",
          "premises": [],
          "conclusion": "ctx :- NOT :: bool : A => bool : A"
        },
        {
          "name": "t_instr_NOT__nat",
          "premises": [],
          "conclusion": "ctx :- NOT :: nat : A => int : A"
        },
        {
          "name": "t_instr_NOT__int",
          "premises": [],
          "conclusion": "ctx :- NOT :: int : A => int : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_NOT__1",
          "premises": [],
          "conclusion": "NOT / True : S => False : S"
        },
        {
          "name": "bs_NOT__2",
          "premises": [],
          "conclusion": "NOT / False : S => True : S"
        },
        {
          "name": "bs_NOT__bit",
          "premises": [],
          "conclusion": "NOT / z : S => ~ z : S"
        }
      ]
    },
    "NEG": {
      "op": "NEG",
      "op_args": "NEG",
      "ty": [
        {
          "name": "t_instr_NEG__nat",
          "premises": [],
          "conclusion": "ctx :- NEG :: nat : A => int : A"
        },
        {
          "name": "t_instr_NEG__int",
          "premises": [],
          "conclusion": "ctx :- NEG :: int : A => int : A"
        },
        {
          "name": "t_instr_NEG__g1",
          "premises": [],
          "conclusion": "ctx :- NEG :: bls12_381_g1 : A => bls12_381_g1 : A"
        },
        {
          "name": "t_instr_NEG__g2",
          "premises": [],
          "conclusion": "ctx :- NEG :: bls12_381_g2 : A => bls12_381_g2 : A"
        },
        {
          "name": "t_instr_NEG__fr",
          "premises": [],
          "conclusion": "ctx :- NEG :: bls12_381_fr : A => bls12_381_fr : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_NEG",
          "premises": [],
          "conclusion": "NEG / z : S => - z : S"
        }
      ]
    },
    "ABS": {
      "op": "ABS",
      "op_args": "ABS",
      "ty": [
        {
          "name": "t_instr_ABS",
          "premises": [],
          "conclusion": "ctx :- ABS :: int : A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_ABS",
          "premises": [],
          "conclusion": "ABS / z : S => abs z : S"
        }
      ]
    },
    "INT": {
      "op": "INT",
      "op_args": "INT",
      "ty": [
        {
          "name": "t_instr_INT__nat",
          "premises": [],
          "conclusion": "ctx :- INT :: nat : A => int : A"
        },
        {
          "name": "t_instr_INT__bls12_381_fr",
          "premises": [],
          "conclusion": "ctx :- INT :: bls12_381_fr : A => int : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_INT",
          "premises": [],
          "conclusion": "INT / z : S => z : S"
        }
      ]
    },
    "ISNAT": {
      "op": "ISNAT",
      "op_args": "ISNAT",
      "ty": [
        {
          "name": "t_instr_ISNAT",
          "premises": [],
          "conclusion": "ctx :- ISNAT :: int : A => option nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_ISNAT__ok",
          "premises": [ "z >= 0" ],
          "conclusion": "ISNAT / z : S => Some ( tonat z ) : S"
        },
        {
          "name": "bs_ISNAT__fail",
          "premises": [ "z < 0" ],
          "conclusion": "ISNAT / z : S => None : S"
        }
      ]
    },
    "SIZE": {
      "op": "SIZE",
      "op_args": "SIZE",
      "ty": [
        {
          "name": "t_instr_SIZE__set",
          "premises": [],
          "conclusion": "ctx :- SIZE :: set cty : A => nat : A"
        },
        {
          "name": "t_instr_SIZE__map",
          "premises": [],
          "conclusion": "ctx :- SIZE :: map kty vty : A => nat : A"
        },
        {
          "name": "t_instr_SIZE__list",
          "premises": [],
          "conclusion": "ctx :- SIZE :: list ty : A => nat : A"
        },
        {
          "name": "t_instr_SIZE__string",
          "premises": [],
          "conclusion": "ctx :- SIZE :: string : A => nat : A"
        },
        {
          "name": "t_instr_SIZE__bytes",
          "premises": [],
          "conclusion": "ctx :- SIZE :: bytes : A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SIZE__string",
          "premises": [],
          "conclusion": "SIZE / s : S => ( length s ) : S"
        },
        {
          "name": "bs_SIZE__bytes",
          "premises": [],
          "conclusion": "SIZE / byt : S => ( length byt ) : S"
        },
        {
          "name": "bs_SIZE__set_nil",
          "premises": [],
          "conclusion": "SIZE / {} : S => 0 : S"
        },
        {
          "name": "bs_SIZE__set_cons",
          "premises": [ "SIZE / tl : S => z : S" ],
          "conclusion": "SIZE / { d ; < tl > } : S => 1 + z : S"
        },
        {
          "name": "bs_SIZE__map_nil",
          "premises": [],
          "conclusion": "SIZE / {} : S => 0 : S"
        },
        {
          "name": "bs_SIZE__map_cons",
          "premises": [ "SIZE / m : S => z : S" ],
          "conclusion": "SIZE / { Elt d1 d2 ; < m > } : S => 1 + z : S"
        },
        {
          "name": "bs_SIZE__list_nil",
          "premises": [],
          "conclusion": "SIZE / {} : S => 0 : S"
        },
        {
          "name": "bs_SIZE__list_cons",
          "premises": [ "SIZE / tl : S => z : S" ],
          "conclusion": "SIZE / { d ; < tl > } : S => 1 + z : S"
        }
      ]
    },
    "CAR": {
      "op": "CAR",
      "op_args": "CAR",
      "ty": [
        {
          "name": "t_instr_CAR",
          "premises": [],
          "conclusion": "ctx :- CAR :: pair ty1 ty2 : A => ty1 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_CAR",
          "premises": [],
          "conclusion": "CAR / ( Pair d1 d2 ) : S => d1 : S"
        }
      ]
    },
    "CDR": {
      "op": "CDR",
      "op_args": "CDR",
      "ty": [
        {
          "name": "t_instr_CDR",
          "premises": [],
          "conclusion": "ctx :- CDR :: pair ty1 ty2 : A => ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_CDR",
          "premises": [],
          "conclusion": "CDR / ( Pair d1 d2 ) : S => d2 : S"
        }
      ]
    },
    "SOME": {
      "op": "SOME",
      "op_args": "SOME",
      "ty": [
        {
          "name": "t_instr_SOME",
          "premises": [],
          "conclusion": "ctx :- SOME :: ty1 : A => option ty1 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SOME",
          "premises": [],
          "conclusion": "SOME / v : S => ( Some v ) : S"
        }
      ]
    },
    "LEFT": {
      "op": "LEFT",
      "op_args": "LEFT ty2",
      "ty": [
        {
          "name": "t_instr_LEFT",
          "premises": [],
          "conclusion": "ctx :- LEFT ty2 :: ty1 : A => or ty1 ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LEFT",
          "premises": [],
          "conclusion": "LEFT ty2 / v : S => ( Left v ) : S"
        }
      ]
    },
    "RIGHT": {
      "op": "RIGHT",
      "op_args": "RIGHT ty1",
      "ty": [
        {
          "name": "t_instr_RIGHT",
          "premises": [],
          "conclusion": "ctx :- RIGHT ty1 :: ty2 : A => or ty1 ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_RIGHT",
          "premises": [],
          "conclusion": "RIGHT ty1 / v : S => ( Right v ) : S"
        }
      ]
    },
    "ADDRESS": {
      "op": "ADDRESS",
      "op_args": "ADDRESS",
      "ty": [
        {
          "name": "t_instr_ADDRESS",
          "premises": [],
          "conclusion": "ctx :- ADDRESS :: contract ty1 : A => address : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_ADDRESS",
          "premises": [],
          "conclusion": "ADDRESS / c : S => address c : S"
        }
      ]
    },
    "CONTRACT": {
      "op": "CONTRACT",
      "op_args": "CONTRACT ty",
      "ty": [
        {
          "name": "t_instr_CONTRACT",
          "premises": [],
          "conclusion":
            "ctx :- CONTRACT ty :: address : A => option ( contract ty ) : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_CONTRACT__ok",
          "premises": [ "get_contract_type addr ty" ],
          "conclusion":
            "CONTRACT ty / addr : S => Some ( contract ty addr ) : S"
        },
        {
          "name": "bs_CONTRACT__fail",
          "premises": [ "get_contract_type addr ty'", "ty' <> ty" ],
          "conclusion": "CONTRACT ty / addr : S => None : S"
        }
      ]
    },
    "SET_DELEGATE": {
      "op": "SET_DELEGATE",
      "op_args": "SET_DELEGATE",
      "ty": [
        {
          "name": "t_instr_SET_DELEGATE",
          "premises": [],
          "conclusion":
            "ctx :- SET_DELEGATE :: option key_hash : A => operation : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SET_DELEGATE__set",
          "premises": [],
          "conclusion": "SET_DELEGATE / Some kh : S => set_delegate kh : S"
        },
        {
          "name": "bs_SET_DELEGATE__remove",
          "premises": [],
          "conclusion": "SET_DELEGATE / None : S => remove_delegation : S"
        }
      ]
    },
    "IMPLICIT_ACCOUNT": {
      "op": "IMPLICIT_ACCOUNT",
      "op_args": "IMPLICIT_ACCOUNT",
      "ty": [
        {
          "name": "t_instr_IMPLICIT_ACCOUNT",
          "premises": [],
          "conclusion":
            "ctx :- IMPLICIT_ACCOUNT :: key_hash : A => contract unit : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_IMPLICIT_ACCOUNT",
          "premises": [],
          "conclusion": "IMPLICIT_ACCOUNT / s : S => implicit_account s : S"
        }
      ]
    },
    "CHAIN_ID": {
      "op": "CHAIN_ID",
      "op_args": "CHAIN_ID",
      "ty": [
        {
          "name": "t_instr_CHAIN_ID",
          "premises": [],
          "conclusion": "ctx :- CHAIN_ID :: A => chain_id : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_CHAIN_ID",
          "premises": [],
          "conclusion": "CHAIN_ID / S => chain_id : S"
        }
      ]
    },
    "PACK": {
      "op": "PACK",
      "op_args": "PACK",
      "ty": [
        {
          "name": "t_instr_PACK",
          "premises": [],
          "conclusion": "ctx :- PACK :: ty : A => bytes : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_PACK",
          "premises": [],
          "conclusion": "PACK / d : S => pack d : S"
        }
      ]
    },
    "UNPACK": {
      "op": "UNPACK",
      "op_args": "UNPACK ty",
      "ty": [
        {
          "name": "t_instr_UNPACK",
          "premises": [],
          "conclusion": "ctx :- UNPACK ty :: bytes : A => option ty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_UNPACK",
          "premises": [],
          "conclusion": "UNPACK ty / byt : S => unpack ty byt : S"
        }
      ]
    },
    "EXEC": {
      "op": "EXEC",
      "op_args": "EXEC",
      "ty": [
        {
          "name": "t_instr_EXEC",
          "premises": [],
          "conclusion": "ctx :- EXEC :: ty1 : lambda ty1 ty2 : A => ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_EXEC",
          "premises": [ "i / d2 : [] => d3 : []" ],
          "conclusion": "EXEC / { i : ty1 -> ty2 } : d2 : S => d3 : S"
        }
      ]
    },
    "LSL": {
      "op": "LSL",
      "op_args": "LSL",
      "ty": [
        {
          "name": "t_instr_LSL",
          "premises": [],
          "conclusion": "ctx :- LSL :: nat : nat : A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LSL",
          "premises": [ "z2 <= 256" ],
          "conclusion": "LSL / z1 : z2 : S => ( z1 << z2 ) : S"
        },
        {
          "name": "bs_LSL__fail",
          "premises": [ "z2 > 256" ],
          "conclusion": "LSL / z1 : z2 : S => [FAILED]"
        }
      ]
    },
    "LSR": {
      "op": "LSR",
      "op_args": "LSR",
      "ty": [
        {
          "name": "t_instr_LSR",
          "premises": [],
          "conclusion": "ctx :- LSR :: nat : nat : A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LSR",
          "premises": [],
          "conclusion": "LSR / z1 : z2 : S => ( z1 >> z2 ) : S"
        }
      ]
    },
    "COMPARE": {
      "op": "COMPARE",
      "op_args": "COMPARE",
      "ty": [
        {
          "name": "t_instr_COMPARE",
          "premises": [],
          "conclusion": "ctx :- COMPARE :: cty : cty : A => int : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_COMPARE__num_lt",
          "premises": [ "z1 < z2" ],
          "conclusion": "COMPARE / z1 : z2 : S => - 1 : S"
        },
        {
          "name": "bs_COMPARE__num_eq",
          "premises": [ "z1 = z2" ],
          "conclusion": "COMPARE / z1 : z2 : S => 0 : S"
        },
        {
          "name": "bs_COMPARE__num_gt",
          "premises": [ "z1 > z2" ],
          "conclusion": "COMPARE / z1 : z2 : S => 1 : S"
        },
        {
          "name": "bs_COMPARE__string_lt",
          "premises": [ "s < t" ],
          "conclusion": "COMPARE / s : t : S => - 1 : S"
        },
        {
          "name": "bs_COMPARE__string_eq",
          "premises": [ "s = t" ],
          "conclusion": "COMPARE / s : t : S => 0 : S"
        },
        {
          "name": "bs_COMPARE__string_gt",
          "premises": [ "s > t" ],
          "conclusion": "COMPARE / s : t : S => 1 : S"
        },
        {
          "name": "bs_COMPARE__pair_left_lt",
          "premises": [ "COMPARE / d1 : d3 : S => - 1 : S" ],
          "conclusion":
            "COMPARE / ( Pair d1 d2 ) : ( Pair d3 d4 ) : S => - 1 : S"
        },
        {
          "name": "bs_COMPARE__pair_left_gt",
          "premises": [ "COMPARE / d1 : d3 : S => 1 : S" ],
          "conclusion":
            "COMPARE / ( Pair d1 d2 ) : ( Pair d3 d4 ) : S => 1 : S"
        },
        {
          "name": "bs_COMPARE__pair_right",
          "premises": [
            "COMPARE / d1 : d3 : S => 0 : S",
            "COMPARE / d2 : d4 : S => z : S"
          ],
          "conclusion":
            "COMPARE / ( Pair d1 d2 ) : ( Pair d3 d4 ) : S => z : S"
        },
        {
          "name": "bs_COMPARE__false_false",
          "premises": [],
          "conclusion": "COMPARE / False : False : S => 0 : S"
        },
        {
          "name": "bs_COMPARE__false_true",
          "premises": [],
          "conclusion": "COMPARE / False : True : S => - 1 : S"
        },
        {
          "name": "bs_COMPARE__true_true",
          "premises": [],
          "conclusion": "COMPARE / True : True : S => 0 : S"
        },
        {
          "name": "bs_COMPARE__true_false",
          "premises": [],
          "conclusion": "COMPARE / True : False : S => 1 : S"
        },
        {
          "name": "bs_COMPARE__none_none",
          "premises": [],
          "conclusion": "COMPARE / None : None : S => 0 : S"
        },
        {
          "name": "bs_COMPARE__none_some",
          "premises": [],
          "conclusion": "COMPARE / None : Some d : S => - 1 : S"
        },
        {
          "name": "bs_COMPARE__some_some",
          "premises": [ "COMPARE / d1 : d2 : S => z : S" ],
          "conclusion": "COMPARE / Some d1 : Some d2 : S => z : S"
        },
        {
          "name": "bs_COMPARE__some_none",
          "premises": [],
          "conclusion": "COMPARE / Some d : None : S => 1 : S"
        },
        {
          "name": "bs_COMPARE__left_left",
          "premises": [ "COMPARE / d1 : d2 : S => z : S" ],
          "conclusion": "COMPARE / Left d1 : Left d2 : S => z : S"
        },
        {
          "name": "bs_COMPARE__left_right",
          "premises": [],
          "conclusion": "COMPARE / Left d1 : Right d2 : S => - 1 : S"
        },
        {
          "name": "bs_COMPARE__right_right",
          "premises": [ "COMPARE / d1 : d2 : S => z : S" ],
          "conclusion": "COMPARE / Right d1 : Right d2 : S => z : S"
        },
        {
          "name": "bs_COMPARE__right_left",
          "premises": [],
          "conclusion": "COMPARE / Right d1 : Left d2 : S => 1 : S"
        },
        {
          "name": "bs_COMPARE__unit_unit",
          "premises": [],
          "conclusion": "COMPARE / Unit : Unit : S => 0 : S"
        }
      ]
    },
    "CONCAT": {
      "op": "CONCAT",
      "op_args": "CONCAT",
      "ty": [
        {
          "name": "t_instr_CONCAT__string",
          "premises": [],
          "conclusion": "ctx :- CONCAT :: string : string : A => string : A"
        },
        {
          "name": "t_instr_CONCAT__string_list",
          "premises": [],
          "conclusion": "ctx :- CONCAT :: list string : A => string : A"
        },
        {
          "name": "t_instr_CONCAT__bytes",
          "premises": [],
          "conclusion": "ctx :- CONCAT :: bytes : bytes : A => bytes : A"
        },
        {
          "name": "t_instr_CONCAT__bytes_list",
          "premises": [],
          "conclusion": "ctx :- CONCAT :: list bytes : A => bytes : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_CONCAT__string",
          "premises": [],
          "conclusion": "CONCAT / s : t : S => ( s ^ t ) : S"
        },
        {
          "name": "bs_CONCAT__string_list_nil",
          "premises": [],
          "conclusion": "CONCAT / {} : S => \\\"\\\" : S"
        },
        {
          "name": "bs_CONCAT__string_list_cons",
          "premises": [ "CONCAT / tl : S => t : S" ],
          "conclusion": "CONCAT / { s ; < tl > } : S => ( s ^ t ) : S"
        },
        {
          "name": "bs_CONCAT__bytes",
          "premises": [],
          "conclusion": "CONCAT / byt1 : byt2 : S => ( byt1 ^ byt2 ) : S"
        },
        {
          "name": "bs_CONCAT__bytes_list_nil",
          "premises": [],
          "conclusion": "CONCAT / {} : byt1 : S => 0x : S"
        },
        {
          "name": "bs_CONCAT__bytes_list_cons",
          "premises": [ "CONCAT / tl : byt1 : S => byt2 : S" ],
          "conclusion":
            "CONCAT / { byt1 ; < tl > } : S => ( byt1 ^ byt2 ) : S"
        }
      ]
    },
    "PAIR": {
      "op": "PAIR",
      "op_args": "PAIR",
      "ty": [
        {
          "name": "t_instr_PAIR",
          "premises": [],
          "conclusion": "ctx :- PAIR :: ty1 : ty2 : A => pair ty1 ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_PAIR",
          "premises": [],
          "conclusion": "PAIR / d1 : d2 : S => ( Pair d1 d2 ) : S"
        }
      ]
    },
    "PAIRN": {
      "op": "PAIRN",
      "op_args": "PAIR n",
      "ty": [
        {
          "name": "t_instr_PAIRN",
          "premises": [],
          "conclusion":
            "ctx :- PAIR n :: ty1 : .... : tyN : A => pair ty1 .... tyN : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_PAIRN",
          "premises": [],
          "conclusion":
            "PAIR n / d1 : .... : dN : S => ( Pair d1 .... dN ) : S"
        }
      ]
    },
    "UNPAIR": {
      "op": "UNPAIR",
      "op_args": "UNPAIR",
      "ty": [
        {
          "name": "t_instr_UNPAIR",
          "premises": [],
          "conclusion": "ctx :- UNPAIR :: pair ty1 ty2 : A => ty1 : ty2 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_UNPAIR",
          "premises": [],
          "conclusion": "UNPAIR / ( Pair d1 d2 ) : S => d1 : d2 : S"
        }
      ]
    },
    "UNPAIRN": {
      "op": "UNPAIRN",
      "op_args": "UNPAIR n",
      "ty": [
        {
          "name": "t_instr_UNPAIRN",
          "premises": [],
          "conclusion":
            "ctx :- UNPAIR n :: pair ty1 .... tyN : A => ty1 : .... : tyN : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_UNPAIRN",
          "premises": [],
          "conclusion":
            "UNPAIR n / ( Pair d1 .... dN ) : S => d1 : .... : dN : S"
        }
      ]
    },
    "GETN": {
      "op": "GETN",
      "op_args": "GET n",
      "ty": [
        {
          "name": "t_instr_GETN__0",
          "premises": [],
          "conclusion": "ctx :- GET ( 0 ) :: ty : A => ty : A"
        },
        {
          "name": "t_instr_GETN__even",
          "premises": [],
          "conclusion":
            "ctx :- GET ( 2 * n ) :: pair ty0 .. tyN ty' : A => ty' : A"
        },
        {
          "name": "t_instr_GETN__odd",
          "premises": [],
          "conclusion":
            "ctx :- GET ( 2 * n + 1 ) :: pair ty0 .. tyN ty' ty'' : A => ty' : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_GETN__0",
          "premises": [],
          "conclusion": "GET 0 / d : S => d : S"
        },
        {
          "name": "bs_GETN__even",
          "premises": [],
          "conclusion": "GET ( 2 * n ) / Pair d0 .. dN d' : S => d' : S"
        },
        {
          "name": "bs_GETN__odd",
          "premises": [],
          "conclusion":
            "GET ( 2 * n + 1 ) / Pair d0 .. dN d' d'' : S => d' : S"
        }
      ]
    },
    "UPDATEN": {
      "op": "UPDATEN",
      "op_args": "UPDATE n",
      "ty": [
        {
          "name": "t_instr_UPDATEN__0",
          "premises": [],
          "conclusion": "ctx :- UPDATE 0 :: ty1 : ty2 : A => ty1 : A"
        },
        {
          "name": "t_instr_UPDATEN__even",
          "premises": [],
          "conclusion":
            "ctx :- UPDATE ( 2 * n ) :: ty' : pair ty0 .. tyN ty'' : A => pair ty0 .. tyN ty' : A"
        },
        {
          "name": "t_instr_UPDATEN__odd",
          "premises": [],
          "conclusion":
            "ctx :- UPDATE ( 2 * n + 1 ) :: ty' : pair ty0 .. tyN ty'' ty''' : A => pair ty0 .. tyN ty' ty''' : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_UPDATEN__0",
          "premises": [],
          "conclusion": "UPDATE 0 / d1 : d2 : S => d1 : S"
        },
        {
          "name": "bs_UPDATEN__even",
          "premises": [],
          "conclusion":
            "UPDATE ( 2 * n ) / d' : Pair d0 .. dN d'' : S => Pair d0 .. dN d' : S"
        },
        {
          "name": "bs_UPDATEN__odd",
          "premises": [],
          "conclusion":
            "UPDATE ( 2 * n + 1 ) / d' : Pair d0 .. dN d'' d''' : S => Pair d0 .. dN d' d''' : S"
        }
      ]
    },
    "MEM": {
      "op": "MEM",
      "op_args": "MEM",
      "ty": [
        {
          "name": "t_instr_MEM__set",
          "premises": [],
          "conclusion": "ctx :- MEM :: cty : set cty : A => bool : A"
        },
        {
          "name": "t_instr_MEM__map",
          "premises": [],
          "conclusion": "ctx :- MEM :: kty : map kty vty : A => bool : A"
        },
        {
          "name": "t_instr_MEM__big_map",
          "premises": [],
          "conclusion": "ctx :- MEM :: kty : big_map kty vty : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_MEM__set_empty",
          "premises": [],
          "conclusion": "MEM / x : {} : S => False : S"
        },
        {
          "name": "bs_MEM__set_later",
          "premises": [
            "COMPARE / x : y : [] => 1 : []", "MEM / x : tl : S => b : S"
          ],
          "conclusion": "MEM / x : { y ; < tl > } : S => b : S"
        },
        {
          "name": "bs_MEM__set_found",
          "premises": [ "COMPARE / x : y : [] => 0 : []" ],
          "conclusion": "MEM / x : { y ; < tl > } : S => True : S"
        },
        {
          "name": "bs_MEM__set_nexists",
          "premises": [ "COMPARE / x : y : [] => - 1 : []" ],
          "conclusion": "MEM / x : { y ; < tl > } : S => False : S"
        },
        {
          "name": "bs_MEM__map_empty",
          "premises": [],
          "conclusion": "MEM / x : {} : S => False : S"
        },
        {
          "name": "bs_MEM__map_later",
          "premises": [
            "COMPARE / x : k : [] => 1 : []", "MEM / x : m : S => b : S"
          ],
          "conclusion": "MEM / x : { Elt k v ; < m > } : S => b : S"
        },
        {
          "name": "bs_MEM__map_now",
          "premises": [ "COMPARE / x : k : [] => 0 : []" ],
          "conclusion": "MEM / x : { Elt k v ; < m > } : S => True : S"
        },
        {
          "name": "bs_MEM__map_nexists",
          "premises": [ "COMPARE / x : k : [] => - 1 : []" ],
          "conclusion": "MEM / x : { Elt k v ; < m > } : S => False : S"
        }
      ]
    },
    "GET": {
      "op": "GET",
      "op_args": "GET",
      "ty": [
        {
          "name": "t_instr_GET__map",
          "premises": [],
          "conclusion":
            "ctx :- GET :: kty : map kty vty : A => option vty : A"
        },
        {
          "name": "t_instr_GET__big_map",
          "premises": [],
          "conclusion":
            "ctx :- GET :: kty : big_map kty vty : A => option vty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_GET__empty",
          "premises": [],
          "conclusion": "GET / x : {} : S => None : S"
        },
        {
          "name": "bs_GET__later",
          "premises": [
            "COMPARE / x : k : [] => 1 : []", "GET / x : m : S => opt_y : S"
          ],
          "conclusion": "GET / x : { Elt k v ; < m > } : S => opt_y : S"
        },
        {
          "name": "bs_GET__now",
          "premises": [ "COMPARE / x : k : [] => 0 : []" ],
          "conclusion": "GET / x : { Elt k v ; < m > } : S => Some v : S"
        },
        {
          "name": "bs_GET__nexists",
          "premises": [ "COMPARE / x : k : [] => - 1 : []" ],
          "conclusion": "GET / x : { Elt k v ; < m > } : S => None : S"
        }
      ]
    },
    "GET_AND_UPDATE": {
      "op": "GET_AND_UPDATE",
      "op_args": "GET_AND_UPDATE",
      "ty": [
        {
          "name": "t_instr_GET_AND_UPDATE__map",
          "premises": [],
          "conclusion":
            "ctx :- GET_AND_UPDATE :: kty : option vty : map kty vty : A => option vty : map kty vty : A"
        },
        {
          "name": "t_instr_GET_AND_UPDATE___big_map",
          "premises": [],
          "conclusion":
            "ctx :- GET_AND_UPDATE :: kty : option vty : big_map kty vty : A => option vty : big_map kty vty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_GET_AND_UPDATE__empty_none",
          "premises": [],
          "conclusion": "GET_AND_UPDATE / x : None : {} : S => None : {} : S"
        },
        {
          "name": "bs_GET_AND_UPDATE__empty_some",
          "premises": [],
          "conclusion":
            "GET_AND_UPDATE / x : Some y : {} : S => None : { Elt x y } : S"
        },
        {
          "name": "bs_GET_AND_UPDATE__later",
          "premises": [
            "COMPARE / x : k : [] => 1 : []",
            "GET_AND_UPDATE / x : opt_y : m : S => opt_y' : m' : S"
          ],
          "conclusion":
            "GET_AND_UPDATE / x : opt_y : { Elt k v ; < m > } : S => opt_y' : { Elt k v ; < m' > } : S"
        },
        {
          "name": "bs_GET_AND_UPDATE__now_none",
          "premises": [ "COMPARE / x : k : [] => 0 : []" ],
          "conclusion":
            "GET_AND_UPDATE / x : None : { Elt k v ; < m > } : S => Some v : m : S"
        },
        {
          "name": "bs_GET_AND_UPDATE__now_some",
          "premises": [ "COMPARE / x : k : [] => 0 : []" ],
          "conclusion":
            "GET_AND_UPDATE / x : Some y : { Elt k v ; < m > } : S => Some v : { Elt k y ; < m > } : S"
        },
        {
          "name": "bs_GET_AND_UPDATE__nexists_none",
          "premises": [ "COMPARE / x : k : [] => - 1 : []" ],
          "conclusion":
            "GET_AND_UPDATE / x : None : { Elt k v ; < m > } : S => None : { Elt k v ; < m > } : S"
        },
        {
          "name": "bs_GET_AND_UPDATE__nexists_some",
          "premises": [ "COMPARE / x : k : [] => - 1 : []" ],
          "conclusion":
            "GET_AND_UPDATE / x : Some y : { Elt k v ; < m > } : S => None : { Elt x y ; < { Elt k v ; < m > } > } : S"
        }
      ]
    },
    "CONS": {
      "op": "CONS",
      "op_args": "CONS",
      "ty": [
        {
          "name": "t_instr_CONS",
          "premises": [],
          "conclusion": "ctx :- CONS :: ty1 : list ty1 : A => list ty1 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_CONS",
          "premises": [],
          "conclusion": "CONS / d : tl : S => { d ; < tl > } : S"
        }
      ]
    },
    "DUP": {
      "op": "DUP",
      "op_args": "DUP",
      "ty": [
        {
          "name": "t_instr_DUP",
          "premises": [],
          "conclusion": "ctx :- DUP :: ty1 : A => ty1 : ty1 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_DUP",
          "premises": [],
          "conclusion": "DUP / d : S => d : d : S"
        }
      ]
    },
    "DUPN": {
      "op": "DUPN",
      "op_args": "DUP n",
      "ty": [
        {
          "name": "t_instr_DUPN",
          "premises": [ "1 + length A = n" ],
          "conclusion": "ctx :- DUP n :: A @ ty1 : B => ty1 : A @ ty1 : B"
        }
      ],
      "semantics": [
        {
          "name": "bs_DUPN",
          "premises": [ "1 + length S1 = n" ],
          "conclusion": "DUP n / S1 ++ d : S2 => d : S1 ++ d : S2"
        }
      ]
    },
    "SWAP": {
      "op": "SWAP",
      "op_args": "SWAP",
      "ty": [
        {
          "name": "t_instr_SWAP",
          "premises": [],
          "conclusion": "ctx :- SWAP :: ty1 : ty2 : A => ty2 : ty1 : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SWAP",
          "premises": [],
          "conclusion": "SWAP / d1 : d2 : S => d2 : d1 : S"
        }
      ]
    },
    "SLICE": {
      "op": "SLICE",
      "op_args": "SLICE",
      "ty": [
        {
          "name": "t_instr_SLICE__string",
          "premises": [],
          "conclusion":
            "ctx :- SLICE :: nat : nat : string : A => option string : A"
        },
        {
          "name": "t_instr_SLICE__bytes",
          "premises": [],
          "conclusion":
            "ctx :- SLICE :: nat : nat : bytes : A => option bytes : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SLICE__string_ok",
          "premises": [ "offset + len < length s" ],
          "conclusion":
            "SLICE / offset : len : s : S => Some ( slice s offset len ) : S"
        },
        {
          "name": "bs_SLICE__string_fail",
          "premises": [ "offset + len >= length s" ],
          "conclusion": "SLICE / offset : len : s : S => None : S"
        },
        {
          "name": "bs_SLICE__bytes_ok",
          "premises": [ "offset + len < length byt" ],
          "conclusion":
            "SLICE / offset : len : byt : S => Some ( slice byt offset len ) : S"
        },
        {
          "name": "bs_SLICE__bytes_fail",
          "premises": [ "offset + len >= length byt" ],
          "conclusion": "SLICE / offset : len : byt : S => None : S"
        }
      ]
    },
    "UPDATE": {
      "op": "UPDATE",
      "op_args": "UPDATE",
      "ty": [
        {
          "name": "t_instr_UPDATE__set",
          "premises": [],
          "conclusion":
            "ctx :- UPDATE :: cty : bool : set cty : A => set cty : A"
        },
        {
          "name": "t_instr_UPDATE__map",
          "premises": [],
          "conclusion":
            "ctx :- UPDATE :: kty : option vty : map kty vty : A => map kty vty : A"
        },
        {
          "name": "t_instr_UPDATE__big_map",
          "premises": [],
          "conclusion":
            "ctx :- UPDATE :: kty : option vty : big_map kty vty : A => big_map kty vty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_UPDATE__set_false",
          "premises": [],
          "conclusion": "UPDATE / x : False : {} : S => {} : S"
        },
        {
          "name": "bs_UPDATE__set_add_nexists",
          "premises": [],
          "conclusion": "UPDATE / x : True : {} : S => { x } : S"
        },
        {
          "name": "bs_UPDATE__set_cont",
          "premises": [
            "COMPARE / x : y : [] => 1 : []",
            "UPDATE / x : b : tl : S => tl' : S"
          ],
          "conclusion":
            "UPDATE / x : b : { y ; < tl > } : S => { y ; < tl' > } : S"
        },
        {
          "name": "bs_UPDATE__set_remove",
          "premises": [ "COMPARE / x : y : [] => 0 : []" ],
          "conclusion": "UPDATE / x : False : { y ; < tl > } : S => tl : S"
        },
        {
          "name": "bs_UPDATE__set_exists",
          "premises": [ "COMPARE / x : y : [] => 0 : []" ],
          "conclusion":
            "UPDATE / x : True : { y ; < tl > } : S => { y ; < tl > } : S"
        },
        {
          "name": "bs_UPDATE__set_remove_nexists",
          "premises": [ "COMPARE / x : y : [] => - 1 : []" ],
          "conclusion":
            "UPDATE / x : False : { y ; < tl > } : S => { y ; < tl > } : S"
        },
        {
          "name": "bs_UPDATE__set_add",
          "premises": [ "COMPARE / x : y : [] => - 1 : []" ],
          "conclusion":
            "UPDATE / x : True : { y ; < tl > } : S => { x ; < { y ; < tl > } > } : S"
        },
        {
          "name": "bs_UPDATE__map_false",
          "premises": [],
          "conclusion": "UPDATE / x : None : {} : S => {} : S"
        },
        {
          "name": "bs_UPDATE__map_add_nexists",
          "premises": [],
          "conclusion": "UPDATE / x : Some y : {} : S => { Elt x y } : S"
        },
        {
          "name": "bs_UPDATE__map_cont",
          "premises": [
            "COMPARE / x : k : [] => 1 : []",
            "UPDATE / x : opt_y : m : S => m' : S"
          ],
          "conclusion":
            "UPDATE / x : opt_y : { Elt k v ; < m > } : S => { Elt k v ; < m' > } : S"
        },
        {
          "name": "bs_UPDATE__map_remove",
          "premises": [ "COMPARE / x : k : [] => 0 : []" ],
          "conclusion":
            "UPDATE / x : None : { Elt k v ; < m > } : S => m : S"
        },
        {
          "name": "bs_UPDATE__map_exists",
          "premises": [ "COMPARE / x : k : [] => 0 : []" ],
          "conclusion":
            "UPDATE / x : Some y : { Elt k v ; < m > } : S => { Elt k y ; < m > } : S"
        },
        {
          "name": "bs_UPDATE__map_remove_nexists",
          "premises": [ "COMPARE / x : k : [] => - 1 : []" ],
          "conclusion":
            "UPDATE / x : None : { Elt k v ; < m > } : S => { Elt k v ; < m > } : S"
        },
        {
          "name": "bs_UPDATE__map_add",
          "premises": [ "COMPARE / x : k : [] => - 1 : []" ],
          "conclusion":
            "UPDATE / x : Some y : { Elt k v ; < m > } : S => { Elt x y ; < { Elt k v ; < m > } > } : S"
        }
      ]
    },
    "TRANSFER_TOKENS": {
      "op": "TRANSFER_TOKENS",
      "op_args": "TRANSFER_TOKENS",
      "ty": [
        {
          "name": "t_instr_TRANSFER_TOKENS",
          "premises": [],
          "conclusion":
            "ctx :- TRANSFER_TOKENS :: ty : mutez : contract ty : A => operation : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_TRANSFER_TOKENS",
          "premises": [],
          "conclusion":
            "TRANSFER_TOKENS / d : z : c : S => transfer_tokens d z c : S"
        }
      ]
    },
    "CHECK_SIGNATURE": {
      "op": "CHECK_SIGNATURE",
      "op_args": "CHECK_SIGNATURE",
      "ty": [
        {
          "name": "t_instr_CHECK_SIGNATURE",
          "premises": [],
          "conclusion":
            "ctx :- CHECK_SIGNATURE :: key : signature : bytes : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_CHECK_SIGNATURE",
          "premises": [],
          "conclusion":
            "CHECK_SIGNATURE / s : sig : byt : S => check_signature s sig byt : S"
        }
      ]
    },
    "ADD": {
      "op": "ADD",
      "op_args": "ADD",
      "ty": [
        {
          "name": "t_instr_ADD__nat_nat",
          "premises": [],
          "conclusion": "ctx :- ADD :: nat : nat : A => nat : A"
        },
        {
          "name": "t_instr_ADD__nat_int",
          "premises": [],
          "conclusion": "ctx :- ADD :: nat : int : A => int : A"
        },
        {
          "name": "t_instr_ADD__int_nat",
          "premises": [],
          "conclusion": "ctx :- ADD :: int : nat : A => int : A"
        },
        {
          "name": "t_instr_ADD__int_int",
          "premises": [],
          "conclusion": "ctx :- ADD :: int : int : A => int : A"
        },
        {
          "name": "t_instr_ADD__timestamp_int",
          "premises": [],
          "conclusion": "ctx :- ADD :: timestamp : int : A => timestamp : A"
        },
        {
          "name": "t_instr_ADD__int_timestamp",
          "premises": [],
          "conclusion": "ctx :- ADD :: int : timestamp : A => timestamp : A"
        },
        {
          "name": "t_instr_ADD__mutez_mutez_mutez",
          "premises": [],
          "conclusion": "ctx :- ADD :: mutez : mutez : A => mutez : A"
        },
        {
          "name": "t_instr_ADD__g1",
          "premises": [],
          "conclusion":
            "ctx :- ADD :: bls12_381_g1 : bls12_381_g1 : A => bls12_381_g1 : A"
        },
        {
          "name": "t_instr_ADD__g2",
          "premises": [],
          "conclusion":
            "ctx :- ADD :: bls12_381_g2 : bls12_381_g2 : A => bls12_381_g2 : A"
        },
        {
          "name": "t_instr_ADD__fr",
          "premises": [],
          "conclusion":
            "ctx :- ADD :: bls12_381_fr : bls12_381_fr : A => bls12_381_fr : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_ADD",
          "premises": [],
          "conclusion": "ADD / z1 : z2 : S => ( z1 + z2 ) : S"
        }
      ]
    },
    "SUB": {
      "op": "SUB",
      "op_args": "SUB",
      "ty": [
        {
          "name": "t_instr_SUB__nat_nat",
          "premises": [],
          "conclusion": "ctx :- SUB :: nat : nat : A => int : A"
        },
        {
          "name": "t_instr_SUB__nat_int",
          "premises": [],
          "conclusion": "ctx :- SUB :: nat : int : A => int : A"
        },
        {
          "name": "t_instr_SUB__int_nat",
          "premises": [],
          "conclusion": "ctx :- SUB :: int : nat : A => int : A"
        },
        {
          "name": "t_instr_SUB__int_int",
          "premises": [],
          "conclusion": "ctx :- SUB :: int : int : A => int : A"
        },
        {
          "name": "t_instr_SUB__timestamp_int",
          "premises": [],
          "conclusion": "ctx :- SUB :: timestamp : int : A => timestamp : A"
        },
        {
          "name": "t_instr_SUB__timestamp_timestamp",
          "premises": [],
          "conclusion": "ctx :- SUB :: timestamp : timestamp : A => int : A"
        },
        {
          "name": "t_instr_SUB__mutez_mutez",
          "premises": [],
          "conclusion": "ctx :- SUB :: mutez : mutez : A => mutez : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SUB",
          "premises": [],
          "conclusion": "SUB / z1 : z2 : S => ( z1 - z2 ) : S"
        }
      ]
    },
    "MUL": {
      "op": "MUL",
      "op_args": "MUL",
      "ty": [
        {
          "name": "t_instr_MUL__nat_nat",
          "premises": [],
          "conclusion": "ctx :- MUL :: nat : nat : A => nat : A"
        },
        {
          "name": "t_instr_MUL__nat_int",
          "premises": [],
          "conclusion": "ctx :- MUL :: nat : int : A => int : A"
        },
        {
          "name": "t_instr_MUL__int_nat",
          "premises": [],
          "conclusion": "ctx :- MUL :: int : nat : A => int : A"
        },
        {
          "name": "t_instr_MUL__int_int",
          "premises": [],
          "conclusion": "ctx :- MUL :: int : int : A => int : A"
        },
        {
          "name": "t_instr_MUL__mutez_nat",
          "premises": [],
          "conclusion": "ctx :- MUL :: mutez : nat : A => mutez : A"
        },
        {
          "name": "t_instr_MUL__nat_mutez",
          "premises": [],
          "conclusion": "ctx :- MUL :: nat : mutez : A => mutez : A"
        },
        {
          "name": "t_instr_MUL__g1_fr",
          "premises": [],
          "conclusion":
            "ctx :- MUL :: bls12_381_g1 : bls12_381_fr : A => bls12_381_g1 : A"
        },
        {
          "name": "t_instr_MUL__g2_fr",
          "premises": [],
          "conclusion":
            "ctx :- MUL :: bls12_381_g2 : bls12_381_fr : A => bls12_381_g2 : A"
        },
        {
          "name": "t_instr_MUL__fr_fr",
          "premises": [],
          "conclusion":
            "ctx :- MUL :: bls12_381_fr : bls12_381_fr : A => bls12_381_fr : A"
        },
        {
          "name": "t_instr_MUL__nat_fr",
          "premises": [],
          "conclusion":
            "ctx :- MUL :: nat : bls12_381_fr : A => bls12_381_fr : A"
        },
        {
          "name": "t_instr_MUL__int_fr",
          "premises": [],
          "conclusion":
            "ctx :- MUL :: int : bls12_381_fr : A => bls12_381_fr : A"
        },
        {
          "name": "t_instr_MUL__fr_nat",
          "premises": [],
          "conclusion":
            "ctx :- MUL :: bls12_381_fr : nat : A => bls12_381_fr : A"
        },
        {
          "name": "t_instr_MUL__fr_int",
          "premises": [],
          "conclusion":
            "ctx :- MUL :: bls12_381_fr : int : A => bls12_381_fr : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_MUL",
          "premises": [],
          "conclusion": "MUL / z1 : z2 : S => ( z1 * z2 ) : S"
        }
      ]
    },
    "EDIV": {
      "op": "EDIV",
      "op_args": "EDIV",
      "ty": [
        {
          "name": "t_instr_EDIV__nat_nat",
          "premises": [],
          "conclusion":
            "ctx :- EDIV :: nat : nat : A => option ( pair nat nat ) : A"
        },
        {
          "name": "t_instr_EDIV__nat_int",
          "premises": [],
          "conclusion":
            "ctx :- EDIV :: nat : int : A => option ( pair int nat ) : A"
        },
        {
          "name": "t_instr_EDIV__int_nat",
          "premises": [],
          "conclusion":
            "ctx :- EDIV :: int : nat : A => option ( pair int nat ) : A"
        },
        {
          "name": "t_instr_EDIV__int_int",
          "premises": [],
          "conclusion":
            "ctx :- EDIV :: int : int : A => option ( pair int nat ) : A"
        },
        {
          "name": "t_instr_EDIV__mutez_nat",
          "premises": [],
          "conclusion":
            "ctx :- EDIV :: mutez : nat : A => option ( pair mutez mutez ) : A"
        },
        {
          "name": "t_instr_EDIV__mutez_mutez",
          "premises": [],
          "conclusion":
            "ctx :- EDIV :: mutez : mutez : A => option ( pair nat mutez ) : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_EDIV__0",
          "premises": [],
          "conclusion": "EDIV / z1 : 0 : S => None : S"
        },
        {
          "name": "bs_EDIV",
          "premises": [ "z2 <> 0" ],
          "conclusion":
            "EDIV / z1 : z2 : S => Some ( Pair ( z1 / z2 ) ( z1 % z2 ) ) : S"
        }
      ]
    },
    "EQ": {
      "op": "EQ",
      "op_args": "EQ",
      "ty": [
        {
          "name": "t_instr_EQ",
          "premises": [],
          "conclusion": "ctx :- EQ :: int : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_EQ__tt",
          "premises": [],
          "conclusion": "EQ / 0 : S => True : S"
        },
        {
          "name": "bs_EQ__ff",
          "premises": [ "z <> 0" ],
          "conclusion": "EQ / z : S => False : S"
        }
      ]
    },
    "NEQ": {
      "op": "NEQ",
      "op_args": "NEQ",
      "ty": [
        {
          "name": "t_instr_NEQ",
          "premises": [],
          "conclusion": "ctx :- NEQ :: int : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_NEQ__ff",
          "premises": [],
          "conclusion": "NEQ / 0 : S => False : S"
        },
        {
          "name": "bs_NEQ__tt",
          "premises": [ "z <> 0" ],
          "conclusion": "NEQ / z : S => True : S"
        }
      ]
    },
    "LT": {
      "op": "LT",
      "op_args": "LT",
      "ty": [
        {
          "name": "t_instr_LT",
          "premises": [],
          "conclusion": "ctx :- LT :: int : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LT__tt",
          "premises": [ "z < 0" ],
          "conclusion": "LT / z : S => True : S"
        },
        {
          "name": "bs_LT__ff",
          "premises": [ "z >= 0" ],
          "conclusion": "LT / z : S => False : S"
        }
      ]
    },
    "GT": {
      "op": "GT",
      "op_args": "GT",
      "ty": [
        {
          "name": "t_instr_GT",
          "premises": [],
          "conclusion": "ctx :- GT :: int : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_GT__tt",
          "premises": [ "z > 0" ],
          "conclusion": "GT / z : S => True : S"
        },
        {
          "name": "bs_GT__ff",
          "premises": [ "z <= 0" ],
          "conclusion": "GT / z : S => False : S"
        }
      ]
    },
    "LE": {
      "op": "LE",
      "op_args": "LE",
      "ty": [
        {
          "name": "t_instr_LE",
          "premises": [],
          "conclusion": "ctx :- LE :: int : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_LE__tt",
          "premises": [ "z <= 0" ],
          "conclusion": "LE / z : S => True : S"
        },
        {
          "name": "bs_LE__ff",
          "premises": [ "z > 0" ],
          "conclusion": "LE / z : S => False : S"
        }
      ]
    },
    "GE": {
      "op": "GE",
      "op_args": "GE",
      "ty": [
        {
          "name": "t_instr_GE",
          "premises": [],
          "conclusion": "ctx :- GE :: int : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_GE__tt",
          "premises": [ "z >= 0" ],
          "conclusion": "GE / z : S => True : S"
        },
        {
          "name": "bs_GE__ff",
          "premises": [ "z < 0" ],
          "conclusion": "GE / z : S => False : S"
        }
      ]
    },
    "OR": {
      "op": "OR",
      "op_args": "OR",
      "ty": [
        {
          "name": "t_instr_OR__bool",
          "premises": [],
          "conclusion": "ctx :- OR :: bool : bool : A => bool : A"
        },
        {
          "name": "t_instr_OR__nat",
          "premises": [],
          "conclusion": "ctx :- OR :: nat : nat : A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_OR__1",
          "premises": [],
          "conclusion": "OR / True : x : S => True : S"
        },
        {
          "name": "bs_OR__2",
          "premises": [],
          "conclusion": "OR / x : True : S => True : S"
        },
        {
          "name": "bs_OR__3",
          "premises": [],
          "conclusion": "OR / False : False : S => False : S"
        },
        {
          "name": "bs_OR__bit",
          "premises": [],
          "conclusion": "OR / z1 : z2 : S => ( z1 | z2 ) : S"
        }
      ]
    },
    "AND": {
      "op": "AND",
      "op_args": "AND",
      "ty": [
        {
          "name": "t_instr_AND__bool",
          "premises": [],
          "conclusion": "ctx :- AND :: bool : bool : A => bool : A"
        },
        {
          "name": "t_instr_AND__nat_nat",
          "premises": [],
          "conclusion": "ctx :- AND :: nat : nat : A => nat : A"
        },
        {
          "name": "t_instr_AND__int_nat",
          "premises": [],
          "conclusion": "ctx :- AND :: int : nat : A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_AND__1",
          "premises": [],
          "conclusion": "AND / True : True : S => True : S"
        },
        {
          "name": "bs_AND__2",
          "premises": [],
          "conclusion": "AND / False : x : S => False : S"
        },
        {
          "name": "bs_AND__3",
          "premises": [],
          "conclusion": "AND / x : False : S => False : S"
        },
        {
          "name": "bs_AND__bit",
          "premises": [],
          "conclusion": "AND / z1 : z2 : S => ( z1 & z2 ) : S"
        }
      ]
    },
    "XOR": {
      "op": "XOR",
      "op_args": "XOR",
      "ty": [
        {
          "name": "t_instr_XOR__bool",
          "premises": [],
          "conclusion": "ctx :- XOR :: bool : bool : A => bool : A"
        },
        {
          "name": "t_instr_XOR__nat",
          "premises": [],
          "conclusion": "ctx :- XOR :: nat : nat : A => nat : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_XOR__1",
          "premises": [],
          "conclusion": "XOR / True : True : S => False : S"
        },
        {
          "name": "bs_XOR__2",
          "premises": [],
          "conclusion": "XOR / False : True : S => True : S"
        },
        {
          "name": "bs_XOR__3",
          "premises": [],
          "conclusion": "XOR / True : False : S => True : S"
        },
        {
          "name": "bs_XOR__4",
          "premises": [],
          "conclusion": "XOR / False : False : S => False : S"
        },
        {
          "name": "bs_XOR__bit",
          "premises": [],
          "conclusion": "XOR / z1 : z2 : S => ( z1 ^ z2 ) : S"
        }
      ]
    },
    "BLAKE2B": {
      "op": "BLAKE2B",
      "op_args": "BLAKE2B",
      "ty": [
        {
          "name": "t_instr_BLAKE2B",
          "premises": [],
          "conclusion": "ctx :- BLAKE2B :: bytes : A => bytes : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_BLAKE2B",
          "premises": [],
          "conclusion": "BLAKE2B / byt : S => hash_blake2b byt : S"
        }
      ]
    },
    "SHA256": {
      "op": "SHA256",
      "op_args": "SHA256",
      "ty": [
        {
          "name": "t_instr_SHA256",
          "premises": [],
          "conclusion": "ctx :- SHA256 :: bytes : A => bytes : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SHA256",
          "premises": [],
          "conclusion": "SHA256 / byt : S => hash_sha256 byt : S"
        }
      ]
    },
    "SHA512": {
      "op": "SHA512",
      "op_args": "SHA512",
      "ty": [
        {
          "name": "t_instr_SHA512",
          "premises": [],
          "conclusion": "ctx :- SHA512 :: bytes : A => bytes : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SHA512",
          "premises": [],
          "conclusion": "SHA512 / byt : S => hash_sha512 byt : S"
        }
      ]
    },
    "KECCAK": {
      "op": "KECCAK",
      "op_args": "KECCAK",
      "ty": [
        {
          "name": "t_instr_KECCAK",
          "premises": [],
          "conclusion": "ctx :- KECCAK :: bytes : A => bytes : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_KECCAK",
          "premises": [],
          "conclusion": "KECCAK / byt : S => hash_keccak byt : S"
        }
      ]
    },
    "SHA3": {
      "op": "SHA3",
      "op_args": "SHA3",
      "ty": [
        {
          "name": "t_instr_SHA3",
          "premises": [],
          "conclusion": "ctx :- SHA3 :: bytes : A => bytes : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SHA3",
          "premises": [],
          "conclusion": "SHA3 / byt : S => hash_sha3 byt : S"
        }
      ]
    },
    "SAPLING_VERIFY_UPDATE": {
      "op": "SAPLING_VERIFY_UPDATE",
      "op_args": "SAPLING_VERIFY_UPDATE",
      "ty": [
        {
          "name": "t_instr_SAPLING_VERIFY_UPDATE",
          "premises": [],
          "conclusion":
            "ctx :- SAPLING_VERIFY_UPDATE :: sapling_transaction ms : sapling_state ms : A => option ( pair int ( sapling_state ms ) ) : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SAPLING_VERIFY_UPDATE__some",
          "premises": [ "sapling_verify_update ( t , s , b , s' ) = True" ],
          "conclusion":
            "SAPLING_VERIFY_UPDATE / t : s : S => Some ( Pair b s' ) : S"
        },
        {
          "name": "bs_SAPLING_VERIFY_UPDATE__none",
          "premises": [ "sapling_verify_update ( t , s , b , s' ) = False" ],
          "conclusion": "SAPLING_VERIFY_UPDATE / t : s : S => None : S"
        }
      ]
    },
    "SAPLING_EMPTY_STATE": {
      "op": "SAPLING_EMPTY_STATE",
      "op_args": "SAPLING_EMPTY_STATE ms",
      "ty": [
        {
          "name": "t_instr_SAPLING_EMPTY_STATE",
          "premises": [],
          "conclusion":
            "ctx :- SAPLING_EMPTY_STATE ms :: A => sapling_state ms : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SAPLING_EMPTY_STATE",
          "premises": [],
          "conclusion": "SAPLING_EMPTY_STATE n / S => {} : S"
        }
      ]
    },
    "TICKET": {
      "op": "TICKET",
      "op_args": "TICKET",
      "ty": [
        {
          "name": "t_instr_TICKET",
          "premises": [],
          "conclusion": "ctx :- TICKET :: cty : nat : A => ticket cty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_TICKET",
          "premises": [],
          "conclusion": "TICKET / x : n : S => Pair ( address self ) x n : S"
        }
      ]
    },
    "READ_TICKET": {
      "op": "READ_TICKET",
      "op_args": "READ_TICKET",
      "ty": [
        {
          "name": "t_instr_READ_TICKET",
          "premises": [],
          "conclusion":
            "ctx :- READ_TICKET :: ticket cty : A => pair address cty nat : ticket cty : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_READ_TICKET",
          "premises": [],
          "conclusion":
            "READ_TICKET / Pair s x n : S => Pair s x n : Pair s x n : S"
        }
      ]
    },
    "SPLIT_TICKET": {
      "op": "SPLIT_TICKET",
      "op_args": "SPLIT_TICKET",
      "ty": [
        {
          "name": "t_instr_SPLIT_TICKET",
          "premises": [],
          "conclusion":
            "ctx :- SPLIT_TICKET :: ticket cty : pair nat nat : A => option ( pair ( ticket cty ) ( ticket cty ) ) : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_SPLIT_TICKET__some",
          "premises": [ "n1 + n2 = n3" ],
          "conclusion":
            "SPLIT_TICKET / Pair s x n3 : Pair n1 n2 : S => Some ( Pair ( Pair s x n1 ) ( Pair s x n2 ) ) : S"
        },
        {
          "name": "bs_SPLIT_TICKET__none",
          "premises": [ "n1 + n2 <> n3" ],
          "conclusion":
            "SPLIT_TICKET / Pair s x n3 : Pair n1 n2 : S => None : S"
        }
      ]
    },
    "JOIN_TICKETS": {
      "op": "JOIN_TICKETS",
      "op_args": "JOIN_TICKETS",
      "ty": [
        {
          "name": "t_instr_JOIN_TICKETS",
          "premises": [],
          "conclusion":
            "ctx :- JOIN_TICKETS :: pair ( ticket cty ) ( ticket cty ) : A => option ( ticket cty ) : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_JOIN_TICKETS__some",
          "premises": [],
          "conclusion":
            "JOIN_TICKETS / Pair ( Pair s x n1 ) ( Pair s x n2 ) : S => Some ( Pair s x ( n1 + n2 ) ) : S"
        },
        {
          "name": "bs_JOIN_TICKETS__none_ticketer",
          "premises": [ "s1 <> s2" ],
          "conclusion":
            "JOIN_TICKETS / Pair ( Pair s1 x1 n1 ) ( Pair s2 x2 n2 ) : S => None : S"
        },
        {
          "name": "bs_JOIN_TICKETS__none_content",
          "premises": [ "x1 <> x2" ],
          "conclusion":
            "JOIN_TICKETS / Pair ( Pair s1 x1 n1 ) ( Pair s2 x2 n2 ) : S => None : S"
        }
      ]
    },
    "PAIRING_CHECK": {
      "op": "PAIRING_CHECK",
      "op_args": "PAIRING_CHECK",
      "ty": [
        {
          "name": "t_instr_PAIRING_CHECK",
          "premises": [],
          "conclusion":
            "ctx :- PAIRING_CHECK :: list ( pair bls12_381_g1 bls12_381_g2 ) : A => bool : A"
        }
      ],
      "semantics": [
        {
          "name": "bs_PAIRING_CHECK__empty",
          "premises": [],
          "conclusion": "PAIRING_CHECK / {} : S => True : S"
        },
        {
          "name": "bs_PAIRING_CHECK__l",
          "premises": [ "bls12_381_pairing_check ( l ) = b" ],
          "conclusion": "PAIRING_CHECK / l : S => b : S"
        }
      ]
    }
  },
  "types": {
    "option": {
      "ty": "option",
      "ty_args": "option ty",
      "related_ops": [
        "CONTRACT", "CREATE_CONTRACT", "EDIV", "GET", "GET_AND_UPDATE",
        "IF_NONE", "ISNAT", "JOIN_TICKETS", "NONE", "SAPLING_VERIFY_UPDATE",
        "SET_DELEGATE", "SLICE", "SOME", "SPLIT_TICKET", "UNPACK", "UPDATE"
      ]
    },
    "list": {
      "ty": "list",
      "ty_args": "list type",
      "related_ops": [
        "CONCAT", "CONS", "IF_CONS", "ITER", "MAP", "NIL", "PAIRING_CHECK",
        "SIZE"
      ]
    },
    "set": {
      "ty": "set",
      "ty_args": "set cty",
      "related_ops": [ "EMPTY_SET", "ITER", "MEM", "SIZE", "UPDATE" ]
    },
    "contract": {
      "ty": "contract",
      "ty_args": "contract type",
      "related_ops": [
        "ADDRESS", "CONTRACT", "IMPLICIT_ACCOUNT", "SELF", "TRANSFER_TOKENS"
      ]
    },
    "operation": {
      "ty": "operation",
      "ty_args": "operation",
      "related_ops": [ "CREATE_CONTRACT", "SET_DELEGATE", "TRANSFER_TOKENS" ]
    },
    "pair": { "ty": "pair", "ty_args": "pair ty1 ty2", "related_ops": [] },
    "or": {
      "ty": "or",
      "ty_args": "or ty1 ty2",
      "related_ops": [ "IF_LEFT", "LEFT", "LOOP_LEFT", "RIGHT" ]
    },
    "lambda": {
      "ty": "lambda",
      "ty_args": "lambda ty1 ty2",
      "related_ops": [ "APPLY", "EXEC", "LAMBDA" ]
    },
    "map": {
      "ty": "map",
      "ty_args": "map kty vty",
      "related_ops": [
        "EMPTY_MAP", "GET", "GET_AND_UPDATE", "ITER", "MAP", "MEM", "SIZE",
        "UPDATE"
      ]
    },
    "big_map": {
      "ty": "big_map",
      "ty_args": "big_map kty vty",
      "related_ops": [
        "EMPTY_BIG_MAP", "GET", "GET_AND_UPDATE", "MEM", "UPDATE"
      ]
    },
    "sapling_transaction": {
      "ty": "sapling_transaction",
      "ty_args": "sapling_transaction n",
      "related_ops": [ "SAPLING_VERIFY_UPDATE" ]
    },
    "sapling_state": {
      "ty": "sapling_state",
      "ty_args": "sapling_state n",
      "related_ops": [ "SAPLING_EMPTY_STATE", "SAPLING_VERIFY_UPDATE" ]
    },
    "ticket": {
      "ty": "ticket",
      "ty_args": "ticket cty",
      "related_ops": [
        "JOIN_TICKETS", "READ_TICKET", "SPLIT_TICKET", "TICKET"
      ]
    },
    "bls12_381_g1": {
      "ty": "bls12_381_g1",
      "ty_args": "bls12_381_g1",
      "related_ops": [ "ADD", "MUL", "NEG", "PAIRING_CHECK" ]
    },
    "bls12_381_g2": {
      "ty": "bls12_381_g2",
      "ty_args": "bls12_381_g2",
      "related_ops": [ "ADD", "MUL", "NEG", "PAIRING_CHECK" ]
    },
    "bls12_381_fr": {
      "ty": "bls12_381_fr",
      "ty_args": "bls12_381_fr",
      "related_ops": [ "ADD", "INT", "MUL", "NEG" ]
    },
    "string": {
      "ty": "string",
      "ty_args": "string",
      "related_ops": [ "CONCAT", "SIZE", "SLICE" ]
    },
    "nat": {
      "ty": "nat",
      "ty_args": "nat",
      "related_ops": [
        "ABS", "ADD", "AND", "EDIV", "INT", "ISNAT", "LEVEL", "LSL", "LSR",
        "MUL", "NEG", "NOT", "OR", "READ_TICKET", "SIZE", "SLICE",
        "SPLIT_TICKET", "SUB", "TICKET", "TOTAL_VOTING_POWER",
        "VOTING_POWER", "XOR"
      ]
    },
    "int": {
      "ty": "int",
      "ty_args": "int",
      "related_ops": [
        "ABS", "ADD", "AND", "COMPARE", "EDIV", "EQ", "GE", "GT", "INT",
        "ISNAT", "LE", "LT", "MUL", "NEG", "NEQ", "NOT",
        "SAPLING_VERIFY_UPDATE", "SUB"
      ]
    },
    "bytes": {
      "ty": "bytes",
      "ty_args": "bytes",
      "related_ops": [
        "BLAKE2B", "CHECK_SIGNATURE", "CONCAT", "KECCAK", "PACK", "SHA256",
        "SHA3", "SHA512", "SIZE", "SLICE", "UNPACK"
      ]
    },
    "bool": {
      "ty": "bool",
      "ty_args": "bool",
      "related_ops": [
        "AND", "CHECK_SIGNATURE", "EQ", "GE", "GT", "IF", "LE", "LOOP", "LT",
        "MEM", "NEQ", "NOT", "OR", "PAIRING_CHECK", "UPDATE", "XOR"
      ]
    },
    "mutez": {
      "ty": "mutez",
      "ty_args": "mutez",
      "related_ops": [
        "ADD", "AMOUNT", "BALANCE", "CREATE_CONTRACT", "EDIV", "MUL", "SUB",
        "TRANSFER_TOKENS"
      ]
    },
    "key_hash": {
      "ty": "key_hash",
      "ty_args": "key_hash",
      "related_ops": [
        "CREATE_CONTRACT", "HASH_KEY", "IMPLICIT_ACCOUNT", "SET_DELEGATE",
        "VOTING_POWER"
      ]
    },
    "address": {
      "ty": "address",
      "ty_args": "address",
      "related_ops": [
        "ADDRESS", "CONTRACT", "CREATE_CONTRACT", "READ_TICKET",
        "SELF_ADDRESS", "SENDER", "SOURCE"
      ]
    },
    "timestamp": {
      "ty": "timestamp",
      "ty_args": "timestamp",
      "related_ops": [ "ADD", "NOW", "SUB" ]
    },
    "never": {
      "ty": "never",
      "ty_args": "never",
      "related_ops": [ "NEVER" ]
    },
    "key": {
      "ty": "key",
      "ty_args": "key",
      "related_ops": [ "CHECK_SIGNATURE", "HASH_KEY" ]
    },
    "unit": {
      "ty": "unit",
      "ty_args": "unit",
      "related_ops": [ "IMPLICIT_ACCOUNT", "UNIT" ]
    },
    "signature": {
      "ty": "signature",
      "ty_args": "signature",
      "related_ops": [ "CHECK_SIGNATURE" ]
    },
    "chain_id": {
      "ty": "chain_id",
      "ty_args": "chain_id",
      "related_ops": [ "CHAIN_ID" ]
    }
  }
}