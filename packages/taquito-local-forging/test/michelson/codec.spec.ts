import { extractRequiredLen, stripLengthPrefixFromBytes } from '../../src/michelson/codec';
import { Uint8ArrayConsumer } from '../../src/uint8array-consumer';

describe('unint8arrayconsumer', () => {
  it('should not stall ', () => {
    const value = Uint8ArrayConsumer.fromHexString(
      '000000d6000000670000000062010000000b48656c6c6f20776f726c6401bdb6f61e4f12c952f807ae7d3341af5367887dac000000000764656661756c74010000000b48656c6c6f20776f726c6401bdb6f61e4f12c952f807ae7d3341af5367887dac000000000764656661756c74000000670000000062010000000b48656c6c6f20776f726c6401bdb6f61e4f12c952f807ae7d3341af5367887dac000000000764656661756c74010000000b48656c6c6f20776f726c6401bdb6f61e4f12c952f807ae7d3341af5367887dac000000000764656661756c74'
    );
    const consumer = new Uint8ArrayConsumer(extractRequiredLen(value));
    const extracted = stripLengthPrefixFromBytes(consumer, 4);
    const arr = extracted.map((val) => Buffer.from(val).toString('hex'));
    expect(arr).toEqual([
      '0000000062010000000b48656c6c6f20776f726c6401bdb6f61e4f12c952f807ae7d3341af5367887dac000000000764656661756c74010000000b48656c6c6f20776f726c6401bdb6f61e4f12c952f807ae7d3341af5367887dac000000000764656661756c74',
      '0000000062010000000b48656c6c6f20776f726c6401bdb6f61e4f12c952f807ae7d3341af5367887dac000000000764656661756c74010000000b48656c6c6f20776f726c6401bdb6f61e4f12c952f807ae7d3341af5367887dac000000000764656661756c74',
    ]);
  });
});
